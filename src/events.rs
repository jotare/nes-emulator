/// Inter-component events in the NES system
///
/// Some of the components in the NES are capable of communicating some events
/// so other components can react to them. This could be flipping a bit in some
/// line, writing to some register...
///
/// This module abstracts this events and provide an event bus so components can
/// be notified or poll for events
///
use std::{
    collections::HashSet,
    sync::{Arc, Mutex, MutexGuard},
};

use crossbeam_channel::{bounded, Receiver, Sender, TryRecvError, TrySendError};
use log::warn;

#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]
pub enum Event {
    /// Switch-off is the event that gracefully stops the whole system
    SwitchOff,

    /// Non-maskable interrupt
    ///
    /// This event is generated by the PPU and is used to communicate the
    /// vertical blank state to the CPU (when CPU can interact again with the
    /// PPU after a frame have been rendered)
    NMI,

    /// PPU has completely computed the next frame, the GUI can now be updated
    /// with it
    FrameReady,
}

#[derive(Debug)]
pub struct EventBus {
    events: HashSet<Event>,
}

impl EventBus {
    pub fn new() -> Self {
        Self {
            events: HashSet::new(),
        }
    }

    /// Emit a new event into the bus
    pub fn emit(&mut self, event: Event) {
        self.events.insert(event);
    }

    /// Check if an event has been emitted
    pub fn emitted(&self, event: Event) -> bool {
        self.events.contains(&event)
    }

    /// Clean the event bus from a specific event. After this, `emitted` will
    /// return `false`
    pub fn mark_as_processed(&mut self, event: Event) {
        self.events.remove(&event);
    }
}

#[derive(Debug)]
pub struct SharedEventBus {
    event_bus: Arc<Mutex<EventBus>>,
}

impl SharedEventBus {
    pub fn new() -> Self {
        Self {
            event_bus: Arc::new(Mutex::new(EventBus::new())),
        }
    }

    pub fn access(&self) -> MutexGuard<'_, EventBus> {
        self.event_bus
            .lock()
            .expect("Can't obtain lock in shared event bus")
    }
}

impl Clone for SharedEventBus {
    fn clone(&self) -> Self {
        Self {
            event_bus: Arc::clone(&self.event_bus),
        }
    }
}

// Keyboard input and reading

pub struct KeyboardChannel {
    sender: Sender<char>,
    receiver: Receiver<char>,
}

impl KeyboardChannel {
    pub fn new() -> Self {
        let (sender, receiver) = bounded(100);
        Self { sender, receiver }
    }

    pub fn publisher(&self) -> KeyboardPublisher {
        KeyboardPublisher {
            sender: self.sender.clone(),
        }
    }

    pub fn listener(&self) -> KeyboardListener {
        KeyboardListener {
            receiver: self.receiver.clone(),
        }
    }
}

impl Default for KeyboardChannel {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug)]
pub struct KeyboardPublisher {
    sender: Sender<char>,
}

impl KeyboardPublisher {
    pub fn push_char(&self, c: char) {
        match self.sender.try_send(c) {
            Ok(()) => {}
            Err(TrySendError::Full(_)) => {
                warn!("Keyboard channel full, dropping char: {c}");
            }
            Err(TrySendError::Disconnected(_)) => panic!("Keyboard channel disconnected"),
        }
    }
}

#[derive(Debug)]
pub struct KeyboardListener {
    receiver: Receiver<char>,
}

impl KeyboardListener {
    /// Read buffered keyboard input
    pub fn read(&self) -> String {
        let mut buffer = String::new();
        while let Some(c) = self.get_char() {
            buffer.push(c);
        }
        buffer
    }

    /// Flush the keyboard input buffer
    pub fn flush(&self) {
        while self.receiver.try_recv().is_ok() {}
    }

    fn get_char(&self) -> Option<char> {
        match self.receiver.try_recv() {
            Ok(c) => Some(c),
            Err(TryRecvError::Empty) => None,
            Err(TryRecvError::Disconnected) => panic!("Keyboard channel disconnected"),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_events() {
        let mut event_bus = EventBus::new();

        assert!(!event_bus.emitted(Event::NMI));

        event_bus.emit(Event::NMI);
        assert!(event_bus.emitted(Event::NMI));

        event_bus.mark_as_processed(Event::NMI);
        assert!(!event_bus.emitted(Event::NMI));
    }
}
