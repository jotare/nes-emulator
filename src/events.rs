use std::sync::atomic::{AtomicBool, Ordering};
/// Inter-component events in the NES system
///
/// Some of the components in the NES are capable of communicating some events
/// so other components can react to them. This could be flipping a bit in some
/// line, writing to some register...
///
/// This module abstracts this events and provide an event bus so components can
/// be notified or poll for events
///
use std::sync::Arc;

use crossbeam_channel::{bounded, Receiver, Sender, TryRecvError, TrySendError};
use log::warn;

#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]
pub enum Event {
    /// Switch-off is the event that gracefully stops the whole system
    SwitchOff,

    /// Reset
    Reset,

    /// Non-maskable interrupt
    ///
    /// This event is generated by the PPU and is used to communicate the
    /// vertical blank state to the CPU (when CPU can interact again with the
    /// PPU after a frame have been rendered)
    NMI,

    /// PPU has completely computed the next frame, the GUI can now be updated
    /// with it
    FrameReady,
}

/// Thread-safe shared event bus capable to efficiently get/set/clear events
///
#[derive(Debug)]
pub struct SharedEventBus {
    frame_ready: Arc<AtomicBool>,
    nmi: Arc<AtomicBool>,
    reset: Arc<AtomicBool>,
    switch_off: Arc<AtomicBool>,
}

impl SharedEventBus {
    pub fn new() -> Self {
        Self {
            frame_ready: Arc::new(AtomicBool::new(false)),
            nmi: Arc::new(AtomicBool::new(false)),
            reset: Arc::new(AtomicBool::new(false)),
            switch_off: Arc::new(AtomicBool::new(false)),
        }
    }

    /// Emit a new event into the bus
    pub fn emit(&self, event: Event) {
        match event {
            Event::FrameReady => self.frame_ready.store(true, Ordering::Relaxed),
            Event::SwitchOff => self.switch_off.store(true, Ordering::Relaxed),
            Event::Reset => self.reset.store(true, Ordering::Relaxed),
            Event::NMI => self.nmi.store(true, Ordering::Relaxed),
        }
    }

    /// Check if an event has been emitted
    pub fn emitted(&self, event: Event) -> bool {
        match event {
            Event::FrameReady => self.frame_ready.load(Ordering::Relaxed),
            Event::SwitchOff => self.switch_off.load(Ordering::Relaxed),
            Event::Reset => self.reset.load(Ordering::Relaxed),
            Event::NMI => self.nmi.load(Ordering::Relaxed),
        }
    }

    /// Clean the event bus from a specific event. After this, `emitted` will
    /// return `false`
    pub fn mark_as_processed(&self, event: Event) {
        match event {
            Event::FrameReady => self.frame_ready.store(false, Ordering::Relaxed),
            Event::SwitchOff => self.switch_off.store(false, Ordering::Relaxed),
            Event::Reset => self.reset.store(false, Ordering::Relaxed),
            Event::NMI => self.nmi.store(false, Ordering::Relaxed),
        }
    }
}

impl Clone for SharedEventBus {
    fn clone(&self) -> Self {
        Self {
            frame_ready: Arc::clone(&self.frame_ready),
            nmi: Arc::clone(&self.nmi),
            reset: Arc::clone(&self.reset),
            switch_off: Arc::clone(&self.switch_off),
        }
    }
}

// Keyboard input and reading

pub enum KeyEvent {
    Pressed(char),
    Released(char),
}

impl KeyEvent {
    pub fn get_char(&self) -> char {
        match self {
            Self::Pressed(c) => *c,
            Self::Released(c) => *c,
        }
    }
}

pub struct KeyboardChannel {
    sender: Sender<KeyEvent>,
    receiver: Receiver<KeyEvent>,
}

impl KeyboardChannel {
    pub fn new() -> Self {
        let (sender, receiver) = bounded(100);
        Self { sender, receiver }
    }

    pub fn publisher(&self) -> KeyboardPublisher {
        KeyboardPublisher {
            sender: self.sender.clone(),
        }
    }

    pub fn listener(&self) -> KeyboardListener {
        KeyboardListener {
            receiver: self.receiver.clone(),
        }
    }
}

impl Default for KeyboardChannel {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug)]
pub struct KeyboardPublisher {
    sender: Sender<KeyEvent>,
}

impl KeyboardPublisher {
    pub fn pressed_char(&self, c: char) {
        match self.sender.try_send(KeyEvent::Pressed(c)) {
            Ok(()) => {}
            Err(TrySendError::Full(_)) => {
                warn!("Keyboard channel full, dropping char: {c}");
            }
            Err(TrySendError::Disconnected(_)) => panic!("Keyboard channel disconnected"),
        }
    }

    pub fn released_char(&self, c: char) {
        match self.sender.try_send(KeyEvent::Released(c)) {
            Ok(()) => {}
            Err(TrySendError::Full(_)) => {
                warn!("Keyboard channel full, dropping char: {c}");
            }
            Err(TrySendError::Disconnected(_)) => panic!("Keyboard channel disconnected"),
        }
    }
}

#[derive(Debug)]
pub struct KeyboardListener {
    receiver: Receiver<KeyEvent>,
}

impl KeyboardListener {
    /// Read buffered keyboard input
    pub fn read(&self) -> Vec<KeyEvent> {
        let mut buffer = Vec::new();
        while let Some(ev) = self.get_event() {
            buffer.push(ev);
        }
        buffer
    }

    /// Flush the keyboard input buffer
    pub fn flush(&self) {
        while self.receiver.try_recv().is_ok() {}
    }

    fn get_event(&self) -> Option<KeyEvent> {
        match self.receiver.try_recv() {
            Ok(ev) => Some(ev),
            Err(TryRecvError::Empty) => None,
            Err(TryRecvError::Disconnected) => panic!("Keyboard channel disconnected"),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_events() {
        let event_bus = SharedEventBus::new();

        assert!(!event_bus.emitted(Event::NMI));

        event_bus.emit(Event::NMI);
        assert!(event_bus.emitted(Event::NMI));

        event_bus.mark_as_processed(Event::NMI);
        assert!(!event_bus.emitted(Event::NMI));
    }
}
